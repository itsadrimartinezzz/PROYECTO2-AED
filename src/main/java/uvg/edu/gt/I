import java.util.*;

// Enum para los géneros
enum Genero {
    ACCION, COMEDIA, ROMANCE, FANTASIA, SLICE_OF_LIFE
}

// Clase Usuario
class Usuario {
    private String id;
    private String nombre;
    private Map<Genero, Integer> preferencias;
    private Map<Anime, Integer> calificaciones;

    public Usuario(String id, String nombre) {
        this.id = id;
        this.nombre = nombre;
        this.preferencias = new HashMap<>();
        this.calificaciones = new HashMap<>();
    }

    public void calificarAnime(Anime anime, int rating) {
        calificaciones.put(anime, rating);
    }

    public Map<Genero, Integer> obtenerPreferencias() {
        return new HashMap<>(preferencias);
    }

    public Map<Anime, Integer> getCalificaciones() {
        return new HashMap<>(calificaciones);
    }
}

// Clase Anime
class Anime {
    private String id;
    private String titulo;
    private List<Genero> generos;
    private Map<String, Float> caracteristicas;

    public Anime(String id, String titulo, List<Genero> generos) {
        this.id = id;
        this.titulo = titulo;
        this.generos = new ArrayList<>(generos);
        this.caracteristicas = new HashMap<>();
        // Inicializar características basadas en géneros
        for(Genero g : generos) {
            caracteristicas.put(g.name(), 1.0f);
        }
    }

    public Map<String, Float> obtenerCaracteristicas() {
        return new HashMap<>(caracteristicas);
    }
}

// Interfaz Recomendador
interface Recomendador {
    List<Anime> generarRecomendacion(Usuario usuario);
}

// Implementación de Filtrado Colaborativo
class RecomendadorColaborativo implements Recomendador {
    private BaseDeDatos base;
    private float umbralSimilitud = 0.5f;

    public RecomendadorColaborativo(BaseDeDatos base) {
        this.base = base;
    }

    private double calcularSimilitud(Usuario u1, Usuario u2) {
        // Implementación simple de similitud del coseno
        Map<Anime, Integer> calif1 = u1.getCalificaciones();
        Map<Anime, Integer> calif2 = u2.getCalificaciones();
        
        double productoPunto = 0;
        double magnitud1 = 0;
        double magnitud2 = 0;

        for(Anime a : calif1.keySet()) {
            if(calif2.containsKey(a)) {
                productoPunto += calif1.get(a) * calif2.get(a);
            }
            magnitud1 += Math.pow(calif1.get(a), 2);
        }

        for(Anime a : calif2.keySet()) {
            magnitud2 += Math.pow(calif2.get(a), 2);
        }

        return productoPunto / (Math.sqrt(magnitud1) * Math.sqrt(magnitud2));
    }

    @Override
    public List<Anime> generarRecomendacion(Usuario usuario) {
        List<Anime> recomendaciones = new ArrayList<>();
        // Lógica de recomendación colaborativa
        for(Usuario otro : base.getUsuarios()) {
            if(!otro.equals(usuario) && calcularSimilitud(usuario, otro) > umbralSimilitud) {
                for(Anime a : otro.getCalificaciones().keySet()) {
                    if(!usuario.getCalificaciones().containsKey(a)) {
                        recomendaciones.add(a);
                    }
                }
            }
        }
        return recomendaciones;
    }
}

// Implementación de Filtrado por Contenido
class RecomendadorContenido implements Recomendador {
    private BaseDeDatos base;
    private Map<String, Float> pesos;

    public RecomendadorContenido(BaseDeDatos base) {
        this.base = base;
        this.pesos = new HashMap<>();
        // Pesos para características (podrían ajustarse)
        pesos.put("ACCION", 0.8f);
        pesos.put("COMEDIA", 0.7f);
        // ... otros pesos
    }

    private double calcularSimilitud(Anime a1, Anime a2) {
        // Similitud basada en características
        Map<String, Float> c1 = a1.obtenerCaracteristicas();
        Map<String, Float> c2 = a2.obtenerCaracteristicas();
        
        double similitud = 0;
        for(String key : c1.keySet()) {
            if(c2.containsKey(key)) {
                similitud += c1.get(key) * c2.get(key) * pesos.getOrDefault(key, 1.0f);
            }
        }
        return similitud;
    }

    @Override
    public List<Anime> generarRecomendacion(Usuario usuario) {
        List<Anime> recomendaciones = new ArrayList<>();
        // Lógica de recomendación por contenido
        for(Anime visto : usuario.getCalificaciones().keySet()) {
            for(Anime candidato : base.getAnimes()) {
                if(!usuario.getCalificaciones().containsKey(candidato) && 
                   calcularSimilitud(visto, candidato) > 0.6) {
                    recomendaciones.add(candidato);
                }
            }
        }
        return recomendaciones;
    }
}

// Clase Base de Datos
class BaseDeDatos {
    private List<Usuario> usuarios = new ArrayList<>();
    private List<Anime> animes = new ArrayList<>();

    public void agregarUsuario(Usuario u) { usuarios.add(u); }
    public void agregarAnime(Anime a) { animes.add(a); }
    public List<Usuario> getUsuarios() { return new ArrayList<>(usuarios); }
    public List<Anime> getAnimes() { return new ArrayList<>(animes); }
}

// Ejemplo de uso
public class Main {
    public static void main(String[] args) {
        // Inicializar base de datos
        BaseDeDatos base = new BaseDeDatos();
        
        // Crear animes
        Anime anime1 = new Anime("A1", "Naruto", Arrays.asList(Genero.ACCION, Genero.COMEDIA));
        Anime anime2 = new Anime("A2", "Your Lie in April", Arrays.asList(Genero.ROMANCE, Genero.SLICE_OF_LIFE));
        
        // Crear usuarios
        Usuario usuario1 = new Usuario("U1", "Juan");
        usuario1.calificarAnime(anime1, 5);
        
        // Agregar a la base
        base.agregarAnime(anime1);
        base.agregarAnime(anime2);
        base.agregarUsuario(usuario1);
        
        // Generar recomendaciones
        Recomendador colaborativo = new RecomendadorColaborativo(base);
        List<Anime> recomendaciones = colaborativo.generarRecomendacion(usuario1);
        
        System.out.println("Recomendaciones colaborativas:");
        recomendaciones.forEach(a -> System.out.println(a.getTitulo()));
    }
}